//! Typed enums for Banner reference data categories.
//!
//! Replaces raw code strings with idiomatic Rust enums. Each category is either
//! Tier 1 (strict — errors on unknown codes) or Tier 2 (lenient — falls back to
//! an `Unknown` variant).
//!
//! Tier 2 enums are generated by the [`tier2_enum!`] macro, which produces:
//! - The enum with an `Unknown { code, description }` fallback variant
//! - `from_code` / `to_code` for Banner code conversion
//! - `from_filter_str` / `to_filter_str` for filter string conversion
//! - A [`FilterParseable`] impl for use with [`FilterValue<T>`]
//!
//! ## Deserialization
//!
//! These enums deliberately omit `Deserialize`. Deserialization from Banner data
//! goes through `from_code`; deserialization from filter strings goes through
//! [`FilterValue<T>`]'s custom `Deserialize` impl.

use std::borrow::Cow;

use serde::{Deserialize, Serialize};
use ts_rs::TS;

/// Parse failure for Tier 1 enums that reject unknown codes.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ParseError {
    pub code: String,
    pub category: &'static str,
}

impl std::fmt::Display for ParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "unknown {} code: '{}'", self.category, self.code)
    }
}

impl std::error::Error for ParseError {}

/// Generates a Tier 2 reference-data enum with an `Unknown` fallback variant.
///
/// Produces: enum definition, `from_code`, `to_code`, `from_filter_str`,
/// `to_filter_str`, [`Display`], [`FilterParseable`], and `From<Self> for FilterValue<Self>`.
macro_rules! tier2_enum {
    (
        $(#[$meta:meta])*
        $vis:vis enum $name:ident, category = $category:literal {
            $(
                $(#[$vmeta:meta])*
                $variant:ident => $code:literal
            ),+ $(,)?
        }
    ) => {
        $(#[$meta])*
        // Deliberately omits Deserialize — see module docs.
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, TS)]
        #[serde(tag = "type")]
        #[ts(export)]
        $vis enum $name {
            $(
                $(#[$vmeta])*
                $variant,
            )+
            /// Unrecognized code.
            Unknown {
                code: String,
                description: String,
            },
        }

        impl $name {
            /// Parse a Banner code, falling back to `Unknown` for unrecognized values.
            pub fn from_code(code: &str, description: Option<&str>) -> Self {
                match code {
                    $( $code => Self::$variant, )+
                    _ => Self::Unknown {
                        code: code.to_owned(),
                        description: description.unwrap_or_default().to_owned(),
                    },
                }
            }

            /// Convert to raw Banner code.
            pub fn to_code(&self) -> &str {
                match self {
                    $( Self::$variant => $code, )+
                    Self::Unknown { code, .. } => code,
                }
            }

            /// Parse from filter string (variant name only).
            ///
            /// The `"raw:"` prefix is handled exclusively by [`FilterParseable::parse_filter`],
            /// keeping this method a clean inverse of [`to_filter_str`] for known variants.
            pub fn from_filter_str(s: &str) -> Result<Self, ParseError> {
                match s {
                    $( stringify!($variant) => Ok(Self::$variant), )+
                    _ => Err(ParseError {
                        code: s.to_owned(),
                        category: concat!($category, " filter"),
                    }),
                }
            }

            /// Serialize to filter string. Unknown variants use `"raw:{code}"` format.
            pub fn to_filter_str(&self) -> Cow<'_, str> {
                match self {
                    $( Self::$variant => Cow::Borrowed(stringify!($variant)), )+
                    Self::Unknown { code, .. } => Cow::Owned(format!("raw:{code}")),
                }
            }
        }

        impl std::fmt::Display for $name {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_str(self.to_code())
            }
        }

        impl From<$name> for FilterValue<$name> {
            fn from(v: $name) -> Self {
                Self::Typed(v)
            }
        }

        impl FilterParseable for $name {
            fn parse_filter(s: &str) -> Result<FilterValue<Self>, ParseError> {
                if let Some(raw_code) = s.strip_prefix("raw:") {
                    return Ok(FilterValue::Raw(raw_code.to_owned()));
                }
                Self::from_filter_str(s).map(FilterValue::Typed)
            }

            fn to_code(&self) -> &str {
                $name::to_code(self)
            }

            fn to_filter_str(&self) -> Cow<'_, str> {
                $name::to_filter_str(self)
            }
        }
    };
}

/// How a course section is delivered.
// Deliberately omits Deserialize — see module docs.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, TS)]
#[serde(tag = "type", content = "variant")]
#[ts(export)]
pub enum InstructionalMethod {
    InPerson,
    Online(OnlineVariant),
    Hybrid(HybridVariant),
    Independent,
}

/// Online delivery sub-variants.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, TS)]
#[ts(export)]
pub enum OnlineVariant {
    /// OA — fully online, no scheduled meetings.
    Async,
    /// OS — fully online, all meetings at scheduled times.
    Sync,
    /// OH — fully online, some synchronous meetings (deprecated Spring 2025).
    Mixed,
}

/// Hybrid delivery sub-variants indicating in-person meeting frequency.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, TS)]
#[ts(export)]
pub enum HybridVariant {
    /// HB — 1 of 2 meeting days in person.
    Half,
    /// H1 — 1 of 3 meeting days in person.
    OneThird,
    /// H2 — 2 of 3 meeting days in person.
    TwoThirds,
}

impl InstructionalMethod {
    /// Returns `Err` for unrecognized codes (Tier 1 — no silent fallback).
    pub fn from_code(code: &str) -> Result<Self, ParseError> {
        match code {
            "FF" => Ok(Self::InPerson),
            "OA" => Ok(Self::Online(OnlineVariant::Async)),
            "OS" => Ok(Self::Online(OnlineVariant::Sync)),
            "OH" => Ok(Self::Online(OnlineVariant::Mixed)),
            "HB" => Ok(Self::Hybrid(HybridVariant::Half)),
            "H1" => Ok(Self::Hybrid(HybridVariant::OneThird)),
            "H2" => Ok(Self::Hybrid(HybridVariant::TwoThirds)),
            "ID" => Ok(Self::Independent),
            _ => Err(ParseError {
                code: code.to_owned(),
                category: "instructional method",
            }),
        }
    }

    /// Convert to raw Banner code.
    pub fn to_code(self) -> &'static str {
        match self {
            Self::InPerson => "FF",
            Self::Online(OnlineVariant::Async) => "OA",
            Self::Online(OnlineVariant::Sync) => "OS",
            Self::Online(OnlineVariant::Mixed) => "OH",
            Self::Hybrid(HybridVariant::Half) => "HB",
            Self::Hybrid(HybridVariant::OneThird) => "H1",
            Self::Hybrid(HybridVariant::TwoThirds) => "H2",
            Self::Independent => "ID",
        }
    }

    /// Parse from dot-notation filter string: "InPerson", "Online.Async", etc.
    pub fn from_filter_str(s: &str) -> Result<Self, ParseError> {
        match s {
            "InPerson" => Ok(Self::InPerson),
            "Online.Async" => Ok(Self::Online(OnlineVariant::Async)),
            "Online.Sync" => Ok(Self::Online(OnlineVariant::Sync)),
            "Online.Mixed" => Ok(Self::Online(OnlineVariant::Mixed)),
            "Hybrid.Half" => Ok(Self::Hybrid(HybridVariant::Half)),
            "Hybrid.OneThird" => Ok(Self::Hybrid(HybridVariant::OneThird)),
            "Hybrid.TwoThirds" => Ok(Self::Hybrid(HybridVariant::TwoThirds)),
            "Independent" => Ok(Self::Independent),
            _ => Err(ParseError {
                code: s.to_owned(),
                category: "instructional method filter",
            }),
        }
    }

    /// Serialize to dot-notation filter string.
    pub fn to_filter_str(self) -> &'static str {
        match self {
            Self::InPerson => "InPerson",
            Self::Online(OnlineVariant::Async) => "Online.Async",
            Self::Online(OnlineVariant::Sync) => "Online.Sync",
            Self::Online(OnlineVariant::Mixed) => "Online.Mixed",
            Self::Hybrid(HybridVariant::Half) => "Hybrid.Half",
            Self::Hybrid(HybridVariant::OneThird) => "Hybrid.OneThird",
            Self::Hybrid(HybridVariant::TwoThirds) => "Hybrid.TwoThirds",
            Self::Independent => "Independent",
        }
    }
}

impl std::fmt::Display for InstructionalMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str((*self).to_code())
    }
}

impl From<InstructionalMethod> for FilterValue<InstructionalMethod> {
    fn from(v: InstructionalMethod) -> Self {
        Self::Typed(v)
    }
}

tier2_enum! {
    /// Physical or virtual campus where a course is offered.
    pub enum Campus, category = "campus" {
        /// 11 — primary San Antonio campus.
        Main => "11",
        /// 1DT — downtown campus.
        Downtown => "1DT",
        /// 1SW — southwest campus.
        Southwest => "1SW",
        /// 1LR — Laredo Education Center.
        Laredo => "1LR",
        /// 9 — online courses for campus students.
        Internet => "9",
        /// ONL — restricted to online degree program students.
        OnlinePrograms => "ONL",
    }
}

tier2_enum! {
    /// Course attribute codes from Banner.
    pub enum Attribute, category = "attribute" {
        // Core Curriculum (Texas state-mandated)
        CoreCommunication => "010",
        CoreMathematics => "020",
        CoreLifePhysicalSciences => "030",
        CoreLanguagePhilosophy => "040",
        CoreCreativeArts => "050",
        CoreAmericanHistory => "060",
        CoreGovernment => "070",
        CoreSocialBehavioral => "080",
        CoreComponentArea => "090",

        // Course Level
        Developmental => "DEVL",
        LowerDivision => "LWER",
        UpperDivision => "UPPR",
        Graduate => "GRAD",

        // Special Designations
        Honors => "HNRS",
        LowCostTextbooks => "LCTB",
        FreeTextbooks => "NCTB",
        Leadership => "ZZLD",
        ServiceLearning => "ZZSL",
        FinishAtUT => "ZZTC",
        UndergraduateResearch => "ZZUR",
    }
}

tier2_enum! {
    /// Which portion of the semester a course section spans.
    pub enum PartOfTerm, category = "part of term" {
        FullTerm => "1",
        FirstHalf => "B5",
        SecondHalf => "B6",
    }
}

/// Trait for enums that can be parsed from filter strings and converted to Banner codes.
pub trait FilterParseable: Sized {
    fn parse_filter(s: &str) -> Result<FilterValue<Self>, ParseError>;
    fn to_code(&self) -> &str;
    fn to_filter_str(&self) -> Cow<'_, str>;
}

/// A filter value that's either a typed enum variant or a raw Banner code.
/// Serializes to/from a plain string (dot-notation or "raw:" prefix).
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum FilterValue<T> {
    Typed(T),
    /// Raw Banner code from "raw:" prefix (Tier 2 Unknown fallback).
    Raw(String),
}

impl<T: FilterParseable> FilterValue<T> {
    /// Resolve to raw Banner code for SQL queries.
    pub fn to_code(&self) -> Cow<'_, str> {
        match self {
            Self::Typed(v) => Cow::Borrowed(v.to_code()),
            Self::Raw(code) => Cow::Borrowed(code),
        }
    }
}

impl<'de, T: FilterParseable> Deserialize<'de> for FilterValue<T> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        T::parse_filter(&s).map_err(serde::de::Error::custom)
    }
}

impl<T: FilterParseable> Serialize for FilterValue<T> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Typed(v) => serializer.serialize_str(&v.to_filter_str()),
            Self::Raw(code) => serializer.serialize_str(&format!("raw:{code}")),
        }
    }
}

// InstructionalMethod is Tier 1: no raw fallback, only typed variants.
impl FilterParseable for InstructionalMethod {
    fn parse_filter(s: &str) -> Result<FilterValue<Self>, ParseError> {
        Self::from_filter_str(s).map(FilterValue::Typed)
    }

    fn to_code(&self) -> &str {
        (*self).to_code()
    }

    fn to_filter_str(&self) -> Cow<'_, str> {
        Cow::Borrowed((*self).to_filter_str())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // --- InstructionalMethod (Tier 1) ---

    #[test]
    fn instructional_method_code_round_trip() {
        let cases = [
            ("FF", InstructionalMethod::InPerson),
            ("OA", InstructionalMethod::Online(OnlineVariant::Async)),
            ("OS", InstructionalMethod::Online(OnlineVariant::Sync)),
            ("OH", InstructionalMethod::Online(OnlineVariant::Mixed)),
            ("HB", InstructionalMethod::Hybrid(HybridVariant::Half)),
            ("H1", InstructionalMethod::Hybrid(HybridVariant::OneThird)),
            ("H2", InstructionalMethod::Hybrid(HybridVariant::TwoThirds)),
            ("ID", InstructionalMethod::Independent),
        ];
        for (code, expected) in cases {
            let parsed = InstructionalMethod::from_code(code).unwrap();
            assert_eq!(parsed, expected, "from_code({code:?})");
            assert_eq!(parsed.to_code(), code, "to_code for {expected:?}");
        }
    }

    #[test]
    fn instructional_method_unknown_code_errors() {
        let err = InstructionalMethod::from_code("ZZ").unwrap_err();
        assert_eq!(err.code, "ZZ");
        assert_eq!(err.category, "instructional method");
        assert_eq!(err.to_string(), "unknown instructional method code: 'ZZ'");
    }

    #[test]
    fn instructional_method_filter_str_round_trip() {
        let cases = [
            ("InPerson", InstructionalMethod::InPerson),
            (
                "Online.Async",
                InstructionalMethod::Online(OnlineVariant::Async),
            ),
            (
                "Online.Sync",
                InstructionalMethod::Online(OnlineVariant::Sync),
            ),
            (
                "Online.Mixed",
                InstructionalMethod::Online(OnlineVariant::Mixed),
            ),
            (
                "Hybrid.Half",
                InstructionalMethod::Hybrid(HybridVariant::Half),
            ),
            (
                "Hybrid.OneThird",
                InstructionalMethod::Hybrid(HybridVariant::OneThird),
            ),
            (
                "Hybrid.TwoThirds",
                InstructionalMethod::Hybrid(HybridVariant::TwoThirds),
            ),
            ("Independent", InstructionalMethod::Independent),
        ];
        for (filter_str, expected) in cases {
            let parsed = InstructionalMethod::from_filter_str(filter_str).unwrap();
            assert_eq!(parsed, expected, "from_filter_str({filter_str:?})");
            assert_eq!(
                parsed.to_filter_str(),
                filter_str,
                "to_filter_str for {expected:?}"
            );
        }
    }

    #[test]
    fn instructional_method_filter_str_rejects_invalid() {
        // Rejects unknown variant names and raw Banner codes alike (Tier 1)
        assert_eq!(
            InstructionalMethod::from_filter_str("Bogus")
                .unwrap_err()
                .code,
            "Bogus"
        );
        assert_eq!(
            InstructionalMethod::from_filter_str("FF").unwrap_err().code,
            "FF"
        );
    }

    // --- Tier 2 enums (macro-generated: Campus, Attribute, PartOfTerm) ---

    #[test]
    fn tier2_code_round_trip() {
        // Campus — exhaustive (representative Tier 2 enum)
        let campus_cases = [
            ("11", Campus::Main),
            ("1DT", Campus::Downtown),
            ("1SW", Campus::Southwest),
            ("1LR", Campus::Laredo),
            ("9", Campus::Internet),
            ("ONL", Campus::OnlinePrograms),
        ];
        for (code, expected) in campus_cases {
            let parsed = Campus::from_code(code, None);
            assert_eq!(parsed, expected, "Campus::from_code({code:?})");
            assert_eq!(parsed.to_code(), code, "Campus::to_code for {expected:?}");
        }

        // Attribute — spot-check (same macro)
        assert_eq!(
            Attribute::from_code("010", None),
            Attribute::CoreCommunication
        );
        assert_eq!(Attribute::from_code("HNRS", None), Attribute::Honors);
        assert_eq!(Attribute::Honors.to_code(), "HNRS");

        // PartOfTerm — spot-check (same macro)
        assert_eq!(PartOfTerm::from_code("1", None), PartOfTerm::FullTerm);
        assert_eq!(PartOfTerm::FullTerm.to_code(), "1");
    }

    #[test]
    fn tier2_unknown_fallback() {
        let campus = Campus::from_code("XYZ", Some("Mystery Campus"));
        assert_eq!(
            campus,
            Campus::Unknown {
                code: "XYZ".to_owned(),
                description: "Mystery Campus".to_owned(),
            }
        );
        assert_eq!(campus.to_code(), "XYZ");

        // None description defaults to empty string
        assert_eq!(
            Campus::from_code("XYZ", None),
            Campus::Unknown {
                code: "XYZ".to_owned(),
                description: String::new(),
            }
        );

        assert_eq!(
            Attribute::from_code("ZZZZ", Some("Custom")).to_code(),
            "ZZZZ"
        );
        assert_eq!(
            PartOfTerm::from_code("Q1", Some("Quarter 1")).to_code(),
            "Q1"
        );
    }

    #[test]
    fn tier2_filter_str_round_trip() {
        // Campus — exhaustive
        for s in [
            "Main",
            "Downtown",
            "Southwest",
            "Laredo",
            "Internet",
            "OnlinePrograms",
        ] {
            assert_eq!(Campus::from_filter_str(s).unwrap().to_filter_str(), s);
        }
        // Attribute — spot-check
        for s in ["CoreCommunication", "Honors", "UndergraduateResearch"] {
            assert_eq!(Attribute::from_filter_str(s).unwrap().to_filter_str(), s);
        }
        // PartOfTerm — exhaustive (only 3 variants)
        for s in ["FullTerm", "FirstHalf", "SecondHalf"] {
            assert_eq!(PartOfTerm::from_filter_str(s).unwrap().to_filter_str(), s);
        }
    }

    // --- FilterValue ---

    #[test]
    fn filter_value_to_code() {
        let typed = FilterValue::Typed(InstructionalMethod::Online(OnlineVariant::Async));
        assert_eq!(&*typed.to_code(), "OA");

        let raw: FilterValue<Campus> = FilterValue::Raw("XYZ".to_owned());
        assert_eq!(&*raw.to_code(), "XYZ");
    }

    #[test]
    fn filter_value_from_impl() {
        let fv: FilterValue<Campus> = Campus::Main.into();
        assert_eq!(fv, FilterValue::Typed(Campus::Main));

        let fv: FilterValue<InstructionalMethod> = InstructionalMethod::InPerson.into();
        assert_eq!(fv, FilterValue::Typed(InstructionalMethod::InPerson));
    }

    #[test]
    fn filter_value_serde_round_trip() {
        // Typed Tier 1
        let fv = FilterValue::Typed(InstructionalMethod::Hybrid(HybridVariant::TwoThirds));
        let json = serde_json::to_string(&fv).unwrap();
        assert_eq!(json, r#""Hybrid.TwoThirds""#);
        assert_eq!(
            serde_json::from_str::<FilterValue<InstructionalMethod>>(&json).unwrap(),
            fv
        );

        // Raw Tier 2
        let fv: FilterValue<Campus> = FilterValue::Raw("XYZ".to_owned());
        let json = serde_json::to_string(&fv).unwrap();
        assert_eq!(json, r#""raw:XYZ""#);
        assert_eq!(
            serde_json::from_str::<FilterValue<Campus>>(&json).unwrap(),
            fv
        );

        // Tier 2 Unknown serializes as raw:
        let fv = FilterValue::Typed(Campus::Unknown {
            code: "ABC".to_owned(),
            description: "Test".to_owned(),
        });
        assert_eq!(serde_json::to_string(&fv).unwrap(), r#""raw:ABC""#);

        // Invalid filter string rejected
        assert!(serde_json::from_str::<FilterValue<InstructionalMethod>>(r#""Bogus""#).is_err());
    }

    #[test]
    fn filter_value_full_round_trip() {
        // Banner code -> enum -> filter string -> deserialize -> Banner code
        let method = InstructionalMethod::from_code("H2").unwrap();
        let filter_str = method.to_filter_str();
        assert_eq!(filter_str, "Hybrid.TwoThirds");
        let fv: FilterValue<InstructionalMethod> =
            serde_json::from_value(serde_json::Value::String(filter_str.to_owned())).unwrap();
        assert_eq!(&*fv.to_code(), "H2");
    }

    // --- parse_filter edge cases ---

    #[test]
    fn parse_filter_edge_cases() {
        // Tier 2: raw: prefix with empty code, with colons
        assert_eq!(
            Campus::parse_filter("raw:").unwrap(),
            FilterValue::Raw(String::new())
        );
        assert_eq!(
            Campus::parse_filter("raw:a:b").unwrap(),
            FilterValue::Raw("a:b".to_owned())
        );

        // Tier 1: rejects raw: prefix entirely
        assert_eq!(
            InstructionalMethod::parse_filter("raw:FF")
                .unwrap_err()
                .code,
            "raw:FF"
        );
    }
}
